<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>TDD presentation</title>

<link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
<link rel="stylesheet" href="../reveal.js/css/theme/sky.css" id="theme">    
<!--<link rel="stylesheet" href="../reveal.js/css/print/pdf.css" id="theme">  -->  
<!--Add support for earlier versions of Internet Explorer -->
<!--[if lt IE 9]>
    <script src="../reveal.js/lib/js/html5shiv.js"></script>
<![endif]-->

<style>
    .updated {
        background-color: #9fc5e8;
    }
    .deleted {
        background-color: #ea9999;
        text-decoration: line-through;
    }
    .added {
        background-color: #b6d7a8;
    }
    
    .reveal p, .reveal li, .reveal code {
        font-size        : 50%!important;
    }
    .reveal code {
        font-size        : 80%!important;
    }
    
    
</style>

</head>
<body>
<div class="reveal">
<div class="slides">
<section id="Title">
<h1>TDD</h1>
</section>

<section id="Title">
<h5>TDD workflow</h5>
<p>Our mooted TDD workflow is on the Wiki @ <a href="https://wiki.ch.hostelworld.com/index.php/TDD_workflow">https://wiki.ch.hostelworld.com/index.php/TDD_workflow</a>
<p>I can't fit the image into this presentation, but let's have a look at it <a href="./Tdd_workflow_1.png" target="_blank">directly</a></p>

</section>

<section id="Demonstration" class="small">
<h5>Demonstration</h5>
<p>We need to write the logic to implement the pagination for the Property Reviews page, eg:</p>
<p><img src="./pagination.png" /></p>
<p>
There are a few rules to consider:
<ul>
<li>there is an optional "previous" flag which is true when there are pages, and the current page is &gt; 1</li>
<li>similarly there is "next" flag which applies when the current page is not the last one</li>
<li>if the current page is amidst the page set, only pages three either side, and two at the beginning and end. Imtermediary pages are filtered out</li>
</ul>
</p>
<p>
The following commits work through implementing a method to fulfil this requirement using TDD.
</p>



</section><section id="COMMIT1">

<h4>COMMIT 1</h4>

<p>Add the minimum class skeleton to not error</p>

<pre><code>class Pagination {
}
</code></pre>

<p>And create the first test. Here I'm simply calling the function. It errors because it doesn't yet exist.</p>

<pre><code>class PaginationTest extends PHPUnit_Framework_TestCase {

    protected $pagination;

    function setup(){
        $this->pagination = new Pagination();
    }
<span class="updated">
    /** @runInSeparateProcess  */
    function testFilter_exists(){
        $this->pagination->filter();
        // won't get this far if it doesn't exist
    }
</span>
}
</code></pre>


</section>
<section id="COMMIT2">
<h4>COMMIT 2</h4>

<p>Create the function. The test now passes.</p>

<pre><code>class Pagination {
<span class="updated">    public function filter(){
    }
</span>}
</code></pre>


</section>
<section id="COMMIT3">
<h4>COMMIT 3</h4>

<p>Add a test to confirm the function returns an array.</p>

<pre><code>function testFilter_returnsAnArray(){
    $result = $this->pagination->filter();
    $this->assertTrue(is_array($result), "Returned value should be an array");
}
</code></pre>


</section>
<section id="COMMIT4">
<h4>COMMIT 4</h4>

<p>Make it return an array.</p>

<pre><code>public function filter(){
<span class="updated">    return [];
</span>}
</code></pre>



</section>
<section id="COMMIT5">
<h4>COMMIT 5</h4>

<p>Test that the array contains the expected keys (realistically could have been rolled into the previous test).</p>

<pre><code>function testFilter_returnsAnArrayWithExpectedKeys(){
    $result = $this->pagination->filter();

    $resultKeys = array_keys($result);
    sort($resultKeys);

    $this->assertEquals(
        ["ellipses", "pages", "showNext", "showPrevious"],
        $resultKeys,
        "Returned array should contain expected keys"
    );
}
</code></pre>


</section>
<section id="COMMIT6">
<h4>COMMIT 6</h4>

<p>Make it return the correct keys</p>

<pre><code>public function filter(){
    return [<span class="updated">
        "pages"         => null,
        "showNext"      => null,
        "showPrevious"  => null,
        "ellipses"      => null</span>
    ];
}
</code></pre>



</section>
<section id="COMMIT7">
<h4>COMMIT 7</h4>

<p>Test for the business rule around the "previous" value.</p>

<pre><code>function testFilter_previousIsFalseWhenOnPage1(){
    $result = $this->pagination->filter([], 1);
    $this->assertFalse(
        $result["showPrevious"],
        "showPrevious should be false when on the first page of results"
    );
}
</code></pre>



</section>
<section id="COMMIT8_1">
<h4>COMMIT 8 - PART 1</h4>

<p>Implement enough of the the logic for the "previous" value to pass the test.</p>

<pre><code>class Pagination {<span class="updated">
    public function filter($pages, $page){
        $showPrevious = $page > 1;
</span>        return [
            "pages"         => null,
            "showNext"      => null,
<span class="updated">            "showPrevious"  => $showPrevious,
</span>            "ellipses"      => null
        ];
    }
</code></pre>
</section>
<section id="COMMIT8_2">    
<h4>COMMIT 8 - PART 2</h4>
<p>We've needed to change the logic of the method so that it takes arguments now, so need to fix some old tests to cater for that.</p>

<pre><code>/** @runInSeparateProcess  */
function testFilter_exists(){
    $this->pagination->filter(<span class="updated">[], 0</span>);
    // won't get this far if it doesn't exist
}

function testFilter_returnsAnArray(){
    $result = $this->pagination->filter(<span class="updated">[], 0</span>);
    $this->assertTrue(is_array($result), "Returned value should be an array");
}

function testFilter_returnsAnArrayWithExpectedKeys(){
    $result = $this->pagination->filter(<span class="updated">[], 0</span>);

    $resultKeys = array_keys($result);
    sort($resultKeys);

    $this->assertEquals(
        ["ellipses", "pages", "showNext", "showPrevious"],
        $resultKeys,
        "Returned array should contain expected keys"
    );
}
</code></pre>



</section>
<section id="COMMIT9">
<h4>COMMIT 9</h4>

<p>Test the next rule for "previous": that it's true on pages other than the first one.<p>

<pre><code>function testFilter_previous_isTrueOnSubsequentPages(){
    $result = $this->pagination->filter([], 2);
    $this->assertTrue(
        $result["showPrevious"],
        "showPrevious should be true on pages other than the first page"
    );
}
</code></pre>

<p>Our first implementation of this was too thorough: our new test actually passes already. Go back and revise logic so that the first test passes, but the second fails.</p>

<pre><code>public function filter($pages, $page){
    $showPrevious = <span class="updated">false</span>;
    return [
        "pages"         => null,
        "showNext"      => null,
        "showPrevious"  => $showPrevious,
        "ellipses"      => null
    ];
}
</code></pre>



</section>
<section id="COMMIT10">
<h4>COMMIT 10</h4>

<p>Now implement the logic to make the second test pass <em>as well</em></p>

<pre><code>public function filter($pages, $page){
    $showPrevious = <span class="updated">$page != 1</span>;
    return [
        "pages"         => null,
        "showNext"      => null,
        "showPrevious"  => $showPrevious,
        "ellipses"      => null
    ];
}
</code></pre>



</section>
<section id="COMMIT11">
<h4>COMMIT 11</h4>

<p>This just tests an edge case I thought of whilst fixing the code earlier.</p>

<pre><code>function testFilter_previous_isFalseIfNoPages(){
    $result = $this->pagination->filter([], 2);
    $this->assertFalse($result["showPrevious"], "showPrevious should be false if there are no pages");
}
</code></pre>



</section>
<section id="COMMIT12">
<h4>COMMIT 12</h4>

<p>Implement the code that deals with the edge case.</p>

<pre><code>public function filter($pages, $page){
    $showPrevious = <span class="updated">count($pages) && </span>$page != 1;
    return [
        "pages"         => null,
        "showNext"      => null,
        "showPrevious"  => $showPrevious,
        "ellipses"      => null
    ];
}
</code></pre>



</section>
<section id="COMMIT13">
<h4>COMMIT 13</h4>

<p>We need to start testing with some pages present in the input array, so create a variable to hold some.</p>

<pre><code>class PaginationTest extends PHPUnit_Framework_TestCase {
    protected $pagination;
    <span class="updated">protected $baselinePages = ["page1","page2","page3"];</span>

</code></pre>

<p>Another boundary test. The business rule is relating to precisely ONE result, so we're now testing either side of that: zero (above), and two.</p>

<pre><code>function testFilter_previous_isTrueOnSubsequentPages(){
    $result = $this->pagination->filter(<span class="updated">$this->baselinePages</span>, 2);
    $this->assertTrue(
        $result["showPrevious"],
        "showPrevious should be true on pages other than the first page"
    );
}
</code></pre>



</section>
<section id="COMMIT14">
<h4>COMMIT 14</h4>

<p>As the business rule for the "next" option is simple and much the same as previous, we can predict these equivalent tests.</p>

<pre><code>function <span class="updated">testFilter_previous_isFalseWhenOnFirstPage</span>(){
    $result = $this->pagination->filter(<span class="updated">$this->baselinePages</span>, 1);
    $this->assertFalse(
        $result["showPrevious"],
        "showPrevious should be false when on the first page of results"
    );
}

// [...]

function testFilter_next_isFalseWhenOnLastPage(){
    $result = $this->pagination->filter($this->baselinePages, count($this->baselinePages));
    $this->assertFalse($result["showNext"], "showNext should be false when on the last page of results");
}

function testFilter_next_isTrueOnEarlierPages(){
    $result = $this->pagination->filter($this->baselinePages, count($this->baselinePages) - 1);
    $this->assertTrue($result["showNext"], "showNext should be true on pages other than the last page");
}

function testFilter_next_isFalseIfNoPages(){
    $result = $this->pagination->filter([], 2);
    $this->assertFalse($result["showNext"], "showNext should be false if there are no pages");
}
</code></pre>



</section>
<section id="COMMIT15">
<h4>COMMIT 15</h4>

<p>And implement the code to make them pass.</p>

<pre><code>public function filter($pages, $page){
<span class="updated">    $showPrevious   = count($pages) && $page != 1;
    $showNext       = count($pages) && $page != count($pages);
</span>    return [
        "pages"         => null,
<span class="updated">        "showNext"      =>  $showNext,
</span>        "showPrevious"  => $showPrevious,
        "ellipses"      => null
    ];
}
</code></pre>



</section>
<section id="COMMIT16">
<h4>COMMIT 16</h4>

<p>We need to start testing some of the arithmetic-based operations, so set some helper variables.</p>

<pre><code>class PaginationTest extends PHPUnit_Framework_TestCase {
    protected $pagination;
    protected $baselinePages    = ["page1","page2","page3"];
<span class="updated">    protected $extremityBuffer  = 2;
    protected $proximityBuffer  = 3;
</span>
</code></pre>

<p>Test the initial ellipsis is set when it's supposed to.</p>

<pre><code>function testFilter_ellipses_firstTrueWhenPageGreaterThanBuffer(){
    $minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + 2;

    $testPages = array_map(function($index){
            return "page$index";
    }, range(1, $minPageWithInitialEllipsis));

    $result = $this->pagination->filter($testPages, $minPageWithInitialEllipsis);
    $this->assertTrue(
        $result["ellipses"][0],
        "First ellipses value should be true if on page {$minPageWithInitialEllipsis}+"
    );
}
</code></pre>


</section>
<section id="COMMIT17">
<h4>COMMIT 17</h4>

<p>Same helper variables here. These might get implemented differently later, but we're dealing with "now".</p>

<pre><code>class Pagination {
<span class="updated">    protected $extremityBuffer  = 2;
    protected $proximityBuffer  = 3;
</span>
</code></pre>

<p>Add logic to implement the initial ellipsis flag.</p>

<pre><code>public function filter($pages, $page){
    $showPrevious   = count($pages) && $page != 1;
    $showNext       = count($pages) && $page != count($pages);
    
<span class="updated">        $ellipses = [false,false];
    if ($page >= $this->extremityBuffer + $this->proximityBuffer + 2){ // 2 = 1 for current page, 1 for at least one page to skip
        $ellipses[0] = true;
    }
</span>    return [
        "pages"         => null,
        "showNext"      => $showNext,
        "showPrevious"  => $showPrevious,
<span class="updated">        "ellipses"      => $ellipses
</span>    ];
}
</code></pre>

<p>It's probably wrong for me to have initialised <code>$ellipses</code> with both values here: <code>[false,false]</code>, as we're not supposed to be implementing the second part of this yet.</p>



</section>
<section id="COMMIT18">
<h4>COMMIT 18</h4>

<p>This functionality has a number of rules predicating the behaviour, so test them individually. And implement them individually.</p>

<pre><code>function testFilter_ellipses_firstTrueWhenPageGreaterThanBuffer(){
    $minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + 2;
<span class="updated">    $testPages = SELF::getTestPages($minPageWithInitialEllipsis);
</span>    $result = $this->pagination->filter($testPages, $minPageWithInitialEllipsis);
    $this->assertTrue(
        $result["ellipses"][0],
        "First ellipses value should be true if on page {$minPageWithInitialEllipsis}+"
    );
}
</code></pre>

<p>I need to generate varying numbers of pages, so I've made a helper method:</p>

<pre><code><span class="updated">protected static function getTestPages($count){
    return array_map(function($index){
        return "page$index";
    }, range(1, $count));
}
</span>
</code></pre>

<p>The actual test:</p>
<pre><code><span class="updated">function testFilter_ellipses_firstTrueWhenPageAtBuffer(){
    $minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + 1;

    $testPages = SELF::getTestPages($minPageWithInitialEllipsis);

    $result = $this->pagination->filter($testPages, $minPageWithInitialEllipsis);
    $this->assertFalse(
        $result["ellipses"][0],
        "First ellipses value should be false if on page {$minPageWithInitialEllipsis}"
    );
}
</span>
</code></pre>




</section>
<section id="COMMIT19">
<h4>COMMIT 19</h4>

<p>I stuffed up and forgot to commit the test before doing the work, so both are in one commit here. There's no rule about what to commit and when, but I figured I'd point it out as the steps go out of order otherwise.</p>

<h5>COMMIT 19a</h5>

<p>Now testing the second ellipsis.</p>

<pre><code>function testFilter_ellipses_secondTrueWhenPageLessThanBuffer(){
    $minPageWithLatterEllipsis = $this->extremityBuffer + $this->proximityBuffer + 2;

    $testPages = SELF::getTestPages($minPageWithLatterEllipsis);

    $result = $this->pagination->filter($testPages, 1);
    $this->assertTrue(
        $result["ellipses"][1],
        "Second ellipses value should be true if on page 1 of {$minPageWithLatterEllipsis}"
    );
}
</code></pre>
</section>
<section id="COMMIT19_B">
<h5>COMMIT 19b</h5>

<p>And implementing its logic.</p>

<pre><code>public function filter($pages, $page){
    $showPrevious   = count($pages) && $page != 1;
    $showNext       = count($pages) && $page != count($pages);

    $ellipses = [false,false];

    if ($page >= $this->extremityBuffer + $this->proximityBuffer + 2){ // 2 = 1 for current page, 1 for at least one page to skip
        $ellipses[0] = true;
    }
<span class="updated">    if ($page <= (count($pages) - ($this->extremityBuffer + $this->proximityBuffer + 1))){
        $ellipses[1] = true;
    }
</span>    return [
        "pages"         => null,
        "showNext"      => $showNext,
        "showPrevious"  => $showPrevious,
        "ellipses"      => $ellipses
    ];
}
</code></pre>



</section>
<section id="COMMIT20">
<h4>COMMIT 20</h4>

<p>More steps to the business logic mean more tests...</p>

<pre><code>function testFilter_ellipses_secondFalseWhenPageAtBuffer(){
    $minPageWithLatterEllipsis = $this->extremityBuffer + $this->proximityBuffer + 2;

    $testPages = SELF::getTestPages($minPageWithLatterEllipsis);

    $result = $this->pagination->filter($testPages, 2);
    $this->assertFalse(
        $result["ellipses"][1],
        "Second ellipses value should be false if on page 2 of {$minPageWithLatterEllipsis}"
    );
}
</code></pre>

<p>I have messed up here: I implemented too much logic in the previous commit, meaning this already passes. I backed the code out to see it break, but I forgot to do an intermediary commit to demonstrate this.</p>


</section>
<section id="COMMIT21">
<h4>COMMIT 21</h4>

<p>Now testing the filtering</p>

<pre><code>function testFilter_pages_pagesFilteredFromBeginningWhenAfterInitialThreshold(){
    $pagesToBeFiltered = 1;
    $minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + $pagesToBeFiltered;

    $testPages = SELF::getTestPages($minPageWithInitialEllipsis);

    $result = $this->pagination->filter($testPages, $minPageWithInitialEllipsis);

    $this->assertEquals(
        count($testPages)-$pagesToBeFiltered,
        count($result["pages"]),
        "$pagesToBeFiltered pages should have been filtered out"
    );

    $pageThatWasFiltered = $testPages[$this->extremityBuffer];
    printf("imploded: %s", implode($result["pages"]));
    $this->assertFalse(
        array_search($pageThatWasFiltered,$result["pages"]),
        sprintf(
            "%s should have been filtered out of [%s]",
            $pageThatWasFiltered, implode($result["pages"])
        )
    );
}
</code></pre>


</section>
<section id="COMMIT22">
<h4>COMMIT 22</h4>

<p>... and some implementation thereof.</p>

<pre><code> public function filter($pages, $page){
    $showPrevious   = count($pages) && $page != 1;
    $showNext       = count($pages) && $page != count($pages);

    $ellipses = [false,false];

    if ($page >= $this->extremityBuffer + $this->proximityBuffer + 2){ // 2 = 1 for current page, 1 for at least one page to skip
        $ellipses[0] = true;
    }

    if ($page <= (count($pages) - ($this->extremityBuffer + $this->proximityBuffer + 1))){
        $ellipses[1] = true;
    }
<span class="updated">    $filteredPages = [];
    foreach($pages as $index=>$value){
        $pageNumber = $index+1;
        if ($ellipses[0]){
            if ($pageNumber > $this->extremityBuffer && $pageNumber < $page - $this->proximityBuffer){
                continue;
            }
        }
        $filteredPages[$index] = $value;
    }
</span>    return [
<span class="updated">        "pages"         => $filteredPages,
</span>
        "showNext"      => $showNext,
        "showPrevious"  => $showPrevious,
        "ellipses"      => $ellipses
    ];
}
</code></pre>
</section>
<section id="COMMIT22_B">
<h4>COMMIT 22 -  revisited</h4>
<p>The implementation here actually identified some bugs in my application of the business logic, so fixed the tests.</p>
    
<pre><code>function testFilter_pages_pagesFilteredFromBeginningWhenAfterInitialThreshold(){
    $pagesToBeFiltered = 1;

    <span class="deleted">$minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + $pagesToBeFiltered;
</span>    <span class="added">$minPageWithInitialEllipsis = $this->extremityBuffer + $this->proximityBuffer + $pagesToBeFiltered + 1;
</span>
    $testPages = SELF::getTestPages($minPageWithInitialEllipsis);

    $result = $this->pagination->filter($testPages, $minPageWithInitialEllipsis);

    $this->assertEquals(
        count($testPages) - $pagesToBeFiltered,
        count($result["pages"]),
        "$pagesToBeFiltered pages should have been filtered out"
    );

    $pageThatWasFiltered = $testPages[$this->extremityBuffer];
    $this->assertFalse(
        array_search($pageThatWasFiltered,$result["pages"]),
        sprintf("%s should have been filtered out of [%s]", $pageThatWasFiltered, implode($result["pages"]))
    );
}
</code></pre>
    
    

</section>
<section id="COMMIT23">
<h4>COMMIT 23</h4>

<p>Testing pages are filtered from the end of the listing too.</p>

<pre><code>function testFilter_pages_pagesFilteredFromEndWhenBeforeFinalThreshold(){
    $minPageWithLatterEllipsis = $this->extremityBuffer + $this->proximityBuffer + 2;

    $testPages = SELF::getTestPages($minPageWithLatterEllipsis);

    $result = $this->pagination->filter($testPages, 1);

    $this->assertEquals(
        count($testPages) - $pagesToBeFiltered,
        count($result["pages"]),
        "$pagesToBeFiltered pages should have been filtered out"
    );

    $indexOfFilteredPage =  count($pages) - $this->extremityBuffer;
    $pageThatWasFiltered = $testPages[$indexOfFilteredPage];
    $this->assertFalse(
        array_search($pageThatWasFiltered,$result["pages"]),
        sprintf("%s should have been filtered out of [%s]", $pageThatWasFiltered, implode($result["pages"]))
    );
}
</code></pre>



</section>
<section id="COMMIT24">
<h4>COMMIT 24</h4>

<p>And, for good measure, both ends at once.</p>

<pre><code>function testFilter_pages_pagesFilteredFromBothEnds(){
    $pagesToBeFilteredFromEachSide = 1;
    $pagesToBeFiltered = $pagesToBeFilteredFromEachSide * 2;

    $minPagesWithBothEllipses = 2 * ($this->extremityBuffer + $this->proximityBuffer + $pagesToBeFilteredFromEachSide) + 1;
    $testPages = SELF::getTestPages($minPagesWithBothEllipses);

    $testPage = ceil($minPagesWithBothEllipses / 2);

    $result = $this->pagination->filter($testPages, $testPage);

    $this->assertEquals(
        count($testPages) - $pagesToBeFiltered,
        count($result["pages"]),
        "$pagesToBeFiltered pages should have been filtered out"
    );

    $indexOfFirstFilteredPage =  $this->extremityBuffer;
    $pageThatWasFiltered = $testPages[$indexOfFirstFilteredPage];

    $this->assertFalse(
        array_search($pageThatWasFiltered, $result["pages"]),
        sprintf("%s should have been filtered out of [%s]", $pageThatWasFiltered, implode($result["pages"]))
    );

    $indexOfLastFilteredPage =  $minPagesWithBothEllipses - $this->extremityBuffer - 1;
    $pageThatWasFiltered = $testPages[$indexOfLastFilteredPage];

    $this->assertFalse(
        array_search($pageThatWasFiltered, $result["pages"]),
        sprintf("%s should have been filtered out of [%s]", $pageThatWasFiltered, implode($result["pages"]))
    );
}
</code></pre>



</section>
<section id="COMMIT25">
<h4>COMMIT 25</h4>

<p>Implementing the logic for those two tests.</p>

<pre><code>public function filter($pages, $page){
<span class="updated">   $pageCount = count($pages);
</span>
    // [...]

    if ($page <= (<span class="updated">$pageCount</span> - ($this->extremityBuffer + $this->proximityBuffer + 1))){
        $ellipses[1] = true;
    }

    $filteredPages = [];
    foreach($pages as $index=>$value){
        $pageNumber = $index+1;
        // [...]
<span class="updated">       if ($ellipses[1]){
            if ($pageNumber > ($page + $this->proximityBuffer) && $pageNumber < ($pageCount - $this->extremityBuffer + 1)){
                continue;
            }
        }
        $filteredPages[$index] = $value;
</span>    }

    return [
        "pages"         => $filteredPages,
        "showNext"      => $showNext,
        "showPrevious"  => $showPrevious,
        "ellipses"      => $ellipses
    ];
}
</code></pre>

<p>We are now code complete, and all tests are passing, so we can start refactoring.</p>



</section>
<section id="COMMIT26">
<h4>COMMIT 26</h4>

<p>Whilst working on this logic, it was way too tricky to keep all the equations in my head, so give them intermediary variables with human-readable names.</p>

<pre><code>public function filter($pages, $page){

    // [...]

    foreach($pages as $index=>$value){
        $pageNumber = $index+1;
        if ($ellipses[0]){
<span class="updated">            $currentPageIsCloseToBeginning = $pageNumber <= $this->extremityBuffer;
            $currentPageIsCloseToSelectedPage = $pageNumber >= $page - $this->proximityBuffer;
            $currentPageIsInFilterZone = !($currentPageIsCloseToBeginning || $currentPageIsCloseToSelectedPage);
            if ($currentPageIsInFilterZone){
</span>                continue;
            }
        }
        if ($ellipses[1]){
<span class="updated">            $currentPageIsCloseToEnd = $pageNumber >= ($pageCount - $this->extremityBuffer + 1);
            $currentPageIsCloseToSelectedPage = $pageNumber <= ($page + $this->proximityBuffer);
            $currentPageIsInFilterZone = !($currentPageIsCloseToEnd || $currentPageIsCloseToSelectedPage);
            if ($currentPageIsInFilterZone){
</span>                continue;
            }
        }
        $filteredPages[$index] = $value;
    }

    // [...]

}
</code></pre>

<p>Tests still pass. All good.</p>


</section>
<section id="COMMIT27">
<h4>COMMIT 27</h4>

<p>I noticed a few places I could use <code>$pageCount</code> but wasn't.</p>

<pre><code>public function filter($pages, $page){
    $pageCount = count($pages);
    <span class="updated">$showPrevious   = $pageCount && $page != 1;</span>
    <span class="updated">$showNext       = $pageCount && $page != $pageCount;</span>
</code></pre>

<p>Tests still pass.</p>



</section>
<section id="COMMIT28">
<h4>COMMIT 28</h4>

<p><code>filter()</code> is a bit too big @ 40 lines, and does a few discrete things. This is a sitter for refactoring. We will factor out the logic for setting each set of keys in the result array.</p>
<p>First: move the next/previous logic into a helper function.</p>
<pre><code>public function filter($pages, $page){
    $pageCount = count($pages);

    <span class="deleted">$showPrevious   = $pageCount && $page != 1;</span>
    <span class="deleted">$showNext       = $pageCount && $page != $pageCount;</span>
    <span class="added">$filters = $this->setNextPrevious($pageCount, $page);
</span>
// [...]

}
<span class="added">private function setNextPrevious($pageCount, $page){
    return [
        "showPrevious"   => $pageCount && $page != 1,
        "showNext"       => $pageCount && $page != $pageCount
    ];
}
</span>
</code></pre>

<p>Tests still pass.</p>



</section>
<section id="COMMIT29">
<h4>COMMIT 29</h4>

<p>Same with the logic for the ellipses key.</p>

<pre><code>public function filter($pages, $page){
    $pageCount = count($pages);
    $filters = $this->setNextPrevious($pageCount, $page);

    <span class="deleted">$filters["ellipses"] = [false,false];</span>
    <span class="deleted">if ($page >= $this->extremityBuffer + $this->proximityBuffer + 2){ // 2 = 1 for current page, 1 for at least one page to skip</span>
    <span class="deleted">    $filters["ellipses"][0] = true;</span>
    <span class="deleted">}</span>
    <span class="deleted">if ($page <= ( $pageCount - ($this->extremityBuffer + $this->proximityBuffer + 1))){</span>
    <span class="deleted">    $filters["ellipses"][1] = true;</span>
    <span class="deleted">}</span>
    <span class="added">$filters["ellipses"] = $this->setEllipses($pageCount, $page);
</span>
    // [...]
}
<span class="added">private function setEllipses($pageCount, $page){
    $ellipses = [false,false];
    if ($page >= $this->extremityBuffer + $this->proximityBuffer + 2){ // 2 = 1 for current page, 1 for at least one page to skip
        $ellipses[0] = true;
    }

    if ($page <= ( $pageCount - ($this->extremityBuffer + $this->proximityBuffer + 1))){
        $ellipses[1] = true;
    }
    return $ellipses;
}
</span>
</code></pre>

<p>Tests still pass.</p>



</section>
<section id="COMMIT30">
<h4>COMMIT 30</h4>

<p>And, finally, the filtering.</p>

<pre><code>public function filter($pages, $page){
    $pageCount = count($pages);

    $filters = $this->setNextPrevious($pageCount, $page);

    $filters["ellipses"] = $this->setEllipses($pageCount, $page);
    <span class="deleted">// all logic pertaining to filters</span>
    <span class="added">$filters["pages"] = $this->filterPages($pages, $page, $filters);
</span>
    return $filters;
}</code></pre>
<p>(cont'ed on next page&hellip;)</p>
</section>
<section id="COMMIT30_B">
<p>&hellip;Cont'ed from previous page</p>
<pre><code><span class="added">private function filterPages($pages, $page, $filters){
    $pageCount = count($pages);
    $filteredPages = [];
    foreach($pages as $index=>$value){
        $pageNumber = $index+1;
        if ($filters["ellipses"][0]){
            $currentPageIsCloseToBeginning = $pageNumber <= $this->extremityBuffer;
            $currentPageIsCloseToSelectedPage = $pageNumber >= $page - $this->proximityBuffer;
            $currentPageIsInFilterZone = !($currentPageIsCloseToBeginning || $currentPageIsCloseToSelectedPage);
            if ($currentPageIsInFilterZone){
                continue;
            }
        }
        if ($filters["ellipses"][1]){
            $currentPageIsCloseToEnd = $pageNumber >= ($pageCount - $this->extremityBuffer + 1);
            $currentPageIsCloseToSelectedPage = $pageNumber <= ($page + $this->proximityBuffer);
            $currentPageIsInFilterZone = !($currentPageIsCloseToEnd || $currentPageIsCloseToSelectedPage);
            if ($currentPageIsInFilterZone){
                continue;
            }
        }
        $filteredPages[$index] = $value;
    }
    return $filteredPages;
}
</span>
</code></pre>

<p>We've done a chunk of rework, but it was all safe as we had tests which would fail if we messed up. And the <code>filter()</code> function is now a more manageable 10 lines (five statements) long; and each helper function is quite small too. <code>filterPages()</code> is 25 lines long which is about as big as we'd want (probably ~20 would be better).</p>
</section>
<section id="err">
	<h2>Err&hellip;</h2>
	<h3 class="fragment">&hellip; that's it</h3>
	<p class="fragment">The code I used in this demo is @ <a href="https://gist.github.com/daccfml/7cbaf3737c6744bd3b69">https://gist.github.com/daccfml/7cbaf3737c6744bd3b69</a>
	<p class="fragment">This presentation is @ <a href="http://adamcameroncoldfusion.cfmldeveloper.com/prezzos/TDD/commits.html">http://adamcameroncoldfusion.cfmldeveloper.com/prezzos/TDD/commits.html</a>
</section>



</div>
</div>
    <script src="../reveal.js/lib/js/head.min.js"></script>
    <script src="../reveal.js/js/reveal.min.js"></script>

    <script>
    Reveal.initialize({
        transition: "none"
    });
    </script>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
  if( window.location.search.match( /print-pdf/gi ) ) {
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = '../reveal.js/css/print/pdf.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  }
</script>
</body>
</html>